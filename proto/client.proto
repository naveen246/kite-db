
syntax = "proto3";

package proto.client;

option go_package = "github.com/naveen246/kite/proto";

/**
 * Kite service that allows clients to discover shard-to-server assignments and
 * submit batches of requests.
 *
 * Clients should connect to a random server to discover the shard-to-server
 * assignments and then send the actual batched requests to the appropriate
 * shard leader. In the future, this may be handled server-side in a proxy
 * layer to allows clients to not be concerned with sharding.
 */
service KiteClient {
  /**
   * Gets all shard-to-server assignments as a stream. Each set of assignments
   * in the response stream will contain all the assignments to bring the client
   * up to date. For example, if a shard is split, the stream will return a
   * single response containing all the new shard assignments as opposed to
   * multiple stream responses, each containing a single shard assignment.
   *
   * Clients should connect to a single random server which will stream the
   * assignments for all shards on all servers.
   */
  rpc GetShardAssignments(ShardAssignmentsRequest)
      returns (stream ShardAssignments);

  /**
   * Batches put, delete and delete_range requests.
   *
   * Clients should send this request to the shard leader. In the future,
   * this may be handled server-side in a proxy layer.
   */
  rpc Write(WriteRequest) returns (WriteResponse);

  /**
   * Batches get requests.
   *
   * Clients should send this request to the shard leader. In the future,
   * this may be handled server-side in a proxy layer.
   */
  rpc Read(ReadRequest) returns (stream ReadResponse);

  /**
   * Requests all the keys between a range of keys.
   *
   * Clients should send an equivalent request to all respective shards.
   */
  rpc List(ListRequest) returns (stream ListResponse);

  /**
   * Client sends shard_id and receives map of key to created/modified/deleted
   */
  rpc GetNotifications(NotificationsRequest) returns (stream NotificationBatch);

  /*
   * Creates a new client session. Sessions are kept alive by regularly sending
   * heartbeats via the KeepAlive rpc.
   */
  rpc CreateSession(CreateSessionRequest) returns (CreateSessionResponse);

  /*
   * Sends a heartbeat to prevent the session from timing out.
   */
  rpc KeepAlive(SessionHeartbeat) returns (KeepAliveResponse);

  /*
   * Closes a session and removes all ephemeral values associated with it.
   */
  rpc CloseSession(CloseSessionRequest) returns (CloseSessionResponse);
}

message ShardAssignmentsRequest {
  string namespace = 1;
}

message ShardAssignments {
  map<string, NamespaceShardsAssignment> namespaces = 1;
}

message NamespaceShardsAssignment {
  repeated ShardAssignment assignments = 1;
  ShardKeyRouter shard_key_router = 2;
}

message ShardAssignment {
  int64 shard_id = 1;
  string leader = 2;
  oneof shard_boundaries {
    Int32HashRange int32_hash_range = 3;
  }
}

enum ShardKeyRouter {
  UNKNOWN = 0;
  XXHASH3 = 1;
}

message Int32HashRange {
  // The minimum inclusive hash that the shard can contain
  fixed32 min_hash_inclusive = 1;

  // The maximum inclusive hash that the shard can contain
  fixed32 max_hash_inclusive = 2;
}

message WriteRequest {
  optional int64 shard_id = 1;
  repeated PutRequest puts = 2;
  repeated DeleteRequest deletes = 3;
  repeated DeleteRangeRequest delete_ranges = 4;
}

message WriteResponse {
  repeated PutResponse puts = 1;
  repeated DeleteResponse deletes = 2;
  repeated DeleteRangeResponse delete_ranges = 3;
}

message ReadRequest {
  optional int64 shard_id = 1;
  repeated GetRequest gets = 2;
}

message ReadResponse {
  repeated GetResponse gets = 1;
}

message PutRequest {
  string key = 1;
  bytes value = 2;
  optional int64 expected_version_id = 3;
  optional int64 session_id = 4;
  optional string client_identity = 5;
}

message PutResponse {
  Status status = 1;
  Version version = 2;
}

message DeleteRequest {
  string key = 1;
  optional int64 expected_version_id = 2;
}

message DeleteResponse {
  Status status = 1;
}

message GetRequest {
  string key = 1;
  bool include_value = 2;
}

message GetResponse {
  Status status = 1;
  Version version = 2;
  optional bytes value = 3;
}

message DeleteRangeRequest {
  string start_inclusive = 1;
  string end_inclusive = 2;
}

message DeleteRangeResponse {
  Status status = 1;
}

enum Status {
  // Operation was successful
  OK = 0;
  // The key was not found
  KEY_NOT_FOUND = 1;
  // The existing version does not match the expected version
  UNEXPECTED_VERSION_ID = 2;
  // The session that the put request referred to is not alive
  SESSION_DOES_NOT_EXIST = 3;
}

message Version {
  int64 version_id = 1;
  int64 modifications_count = 2;
  fixed64 created_timestamp = 3;
  fixed64 modified_timestamp = 4;
  optional int64 session_id = 5;
  optional string client_identity = 6;
}

message ListRequest {
  optional int64 shard_id = 1;
  string start_inclusive = 2;
  string end_inclusive = 3;
}

message ListResponse {
  repeated string keys = 1;
}

message NotificationsRequest {
  int64 shard_id = 1;
  optional int64 start_offset_exclusive = 2;
}

message NotificationBatch {
  int64 shard_id = 1;
  int64 offset = 2;
  fixed64 timestamp = 3;
  map<string, Notification> notifications = 4;
}

message Notification {
  NotificationType type = 1;
  optional int64 version_id = 2;
}

enum NotificationType {
  KEY_CREATED = 0;
  KEY_MODIFIED = 1;
  KEY_DELETED = 2;
}

message CreateSessionRequest {
  int64 shard_id = 1;
  uint32 session_timeout_ms = 2;
  string client_identity = 3;
}

message CreateSessionResponse {
  int64 session_id = 1;
}

message SessionHeartbeat {
  int64 shard_id = 1;
  int64 session_id = 2;
}

message KeepAliveResponse {}

message CloseSessionRequest {
  int64 shard_id = 1;
  int64 session_id = 2;
}

message CloseSessionResponse {}